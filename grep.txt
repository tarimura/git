複数のパターンで検索するには 2015/07/21

-e オプションでパターンを複数指定すればOR検索になる。

# APATTERN か BPATTERN どちらかまたは両方のある行を検索
grep -e APATTERN -e BPATTERN foo.txt

以下のようにしても同じだが。

grep -E 'APATTERN|BPATTERN' foo.txt






grep コマンド 2015/05/21

ファイルや標準入力から正規表現でマッチする行を探し出すコマンド。

ログファイルの中から特定のログを探し出したり、ソースコード一式のあるディレクトリで特定のメソッド名などを定義・呼び出ししているところを探したり、いろいろな目的で使う。

※ grepよりも高速に検索できる ack-grep などもある

※ Perlにはgrepという関数がある
基本的な使い方 2015/05/21

grep [オプション...] パターン [ファイル...]

ファイルを指定しないと標準入力をパターンマッチングする。

私がソースコード一式のディレクトリの中から特定の単語を探すときには、再帰的に検索、かつ行番号もほしいので、たいてい

grep -rn foo *

のように -rn オプションを付けて使っている。これはディレクトリを再帰的にたどり、見つかった行は行番号を付して表示するオプションである。

gitレポジトリのディレクトリで最後の*を.にして実行すると.gitの中も検索されちゃうので、とりあえず最後は * にする癖にしている。
スポンサーリンク
オプション 2015/06/29

-a, --text, --binary-files=text
    通常だとgrepがバイナリだと認識してしまうファイルも強制的にテキストとして認識させる。 テキストファイルでも最初の方に少しテキストでないバイナリがゴミとかで含まれちゃっていると、 grepはバイナリファイルだと勘違いしてしまう。バイナリ扱いになってしまうと、差分の内容が表示されないので、 無理にテキストファイルとして扱わせるオプション。
-A 行数
    このオプションを指定するとマッチした行の後も指定した行数を出力する。
-B 行数
    このオプションを指定するとマッチした行の前も指定した行数を出力する。
--color=always
    カラーで表示する。これを付けなくてもデフォルトでカラー表示かもしれないが、 出力をパイプでつないだときは自分の環境ではこのオプションを付けないとカラー表示にならなかった。 パイプなのにカラー表示したい、というのは | less -R を後ろにつなげるとき。
-E
    拡張正規表現を使う。 (foo|bar) のような表記の正規表現を使うには、 -E が必要。
-i
    大文字小文字を区別せずにマッチングをする。
-l (小文字エル)
    マッチしたファイルのファイル名のみを出力する。
-L
    マッチしなかったファイルのファイル名を出力する。
--line-buffered
    行ごとのバッファリングにする。tail -f などからパイプで受け取るときに便利。
-n
    検索結果の出力に行番号をつける。
-o
    マッチした部分のみを表示する。このオプションがなければマッチした行全体を表示する。
-r
    ディレクトリを再帰的にたどって検索する。
-v
    通常とは逆に、マッチしない行を出力する。

HOWTO
ログファイルなどの tail -f の出力をgrepで絞り込んで表示するには 2013/07/03

tail -f access_log | grep --line-buffered hogehoge

--line-buffered を付けないとgrepがバッファリングをしてしまって、リアルタイムに表示されなくなってしまう。
Binary file foo.txt matches というように表示されてしまう場合 2014/08/28

テキストファイルをgrepしたつもりなのに、Binary File と言われてしまったら、オプション -a を付ける。

例

grep -a blahbla foo.txt

-a の代わりに --text や --binary-files=text でもよい。
シェルスクリプトでファイルにパターンが見つかるかどうかで分岐をさせるには 2014/09/28

パターンがファイルに見つからない場合に終了コード1を返すので、以下のように書けばよい。

if grep PATTERN FILE_PATH >/dev/null; then
    # パターンが見つかる場合
else
    # パターンが見つからない場合
fi

マッチした行の前後数行を表示するには 2015/04/14

-A オプションと -B オプションで表示する行数を指定する。

-A はマッチした行の後ろ(After)を何行表示するか、-B はマッチした行の前(Before)を何行表示するか、を指定する。

# マッチした行とその前5行、後ろ3行を表示
grep -A3 -B5 blahbla foo.txt

複数のパターンで検索するには 2015/07/21

-e オプションでパターンを複数指定すればOR検索になる。

# APATTERN か BPATTERN どちらかまたは両方のある行を検索
grep -e APATTERN -e BPATTERN foo.txt

以下のようにしても同じだが。

grep -E 'APATTERN|BPATTERN' foo.txt

大文字小文字区別せずに検索するには 2015/07/21

-i オプションを付けると大文字小文字区別せずに検索してくれる。

grep -i PATTERN foo.txt

行頭または行末に限定してパターンを検索するには 2015/09/11

行頭を表す正規表現 ^ または行末を表す正規表現 $ を使う。

行頭の hoge を検索する例

$ grep '^hoge' foo.txt

行末の hoge を検索する例

$ grep 'hoge$' foo.txt

逆に行頭または行末を除外してパターンを検索するには 2015/09/11

行頭以外の hoge を検索する例。つまり行の途中や行末に限定。

$ grep '[^^]hoge' foo.txt

行末以外の hoge を検索する例。つまり行の先頭や行の途中に限定。

$ grep '[^$]hoge' foo.txt

[] の中の1文字目が ^ の場合は [] の中の文字以外という意味で、 [^abc] と書くと、abc 以外の任意の1文字となる。そこに行頭を表す ^ を入れて、 [^^] とすると行頭以外の任意の1文字という意味になる。ハイライト表示させるとわかるが、hogeの前の1文字もハイライトになってパターンにマッチしていることがわかる。

同様に [^$] と書くと、行末($)以外の任意の1文字という意味になる。従ってhogeの次の1文字もハイライトになる。




 【正規表現】文字列の否定、ある文字列を含まない

「abc」という文字列で始まらない
---------------------
^(?!abc).+$
---------------------

「abc」という文字列を含まない
---------------------
^(?!.*abc).+$
---------------------

Aの直後から「abc」という文字列を含まない繰り返し
---------------------
A((?!abc).)*?
---------------------

直後に「ABC」も「XYZ」もこないY
---------------------
Y(?!(ABC|XYZ))
---------------------

↓↓もう少し詳しく理解する。↓↓

「(?!」と「)」で文字列を囲む正規表現を否定的先読みという。

これを利用すると、囲まれた文字（パターン）がある文字の直後に存在しない位置にマッチする。普通、正規表現はマッチする文字列を見つけるが、(?!――)はその位置を見つけるだけである。「^」が行頭、「$」が行末の場所を示すのと同じように(?!――)も場所を示すだけ。

次のパターンと比較すると理解しやすい。

行頭から続く文字を繰り返している
-----------------
^.*
-----------------

（Aの直後から）abcという文字列を含まない位置にある文字を繰り返している
-----------------
A((?!abc).)*
-----------------

くどいようだが赤字はあくまでも位置を示す。